<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Woofswap - Swap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #e68a00; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ff9100;
        }
        .token-select {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .token-select div {
            display: flex;
            align-items: center;
        }
        .token-select img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        .token-select .placeholder {
            width: 24px;
            height: 24px;
            background: #4a4f7a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: #4a4f7a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
        }
        .percentage-buttons button:hover { background: #5a5f8a; }
        .switch-button {
            text-align: center;
            margin: 15px 0;
        }
        .switch-button button {
            padding: 10px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:hover, .switch-button button:hover { background: #e68a00; }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            background: var(--card-bg);
            margin: 15% auto;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            border-radius: var(--border-radius);
            max-height: 70vh;
            overflow-y: auto;
        }
        .token-item {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            border-radius: 10px;
        }
        .token-item:hover { background: var(--input-bg); }
        .token-item img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
        }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .slippage-info, .swap-note {
            font-size: 0.9em;
            color: #ff9100;
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .dog-section {
            text-align: center;
            margin-top: 20px;
        }
        .dog-section img {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
        }
        .dog-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .modal-content { margin: 10% auto; }
            .percentage-buttons button { padding: 5px; }
            .dog-section img { width: 50px; height: 50px; }
            .dog-message { font-size: 0.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">Woofswap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>From</span>
                <span id="fromBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="fromToken">
                <div>
                    <img src="images/bone.png" alt="BONE">
                    <span id="fromTokenSymbol">BONE</span>
                </div>
                <span></span>
            </div>
            <input type="number" id="fromAmount" placeholder="0.0" step="0.01" oninput="calculateOutput()">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
        </div>
        <div class="switch-button">
            <button onclick="switchTokens()">↓↑</button>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>To</span>
                <span id="toBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="toToken">
                <div>
                    <div class="placeholder">?</div>
                    <span>Select a token</span>
                </div>
                <span>▼</span>
            </div>
            <div class="slippage-info">Default Slippage: 0.5%</div>
            <div class="swap-note" id="swapNote">Amount automatically calculated by Woofswap</div>
        </div>
        <button class="swap-button" onclick="swapTokens()">Swap</button>
        <div class="dog-section">
            <img src="images/shiba.gif" alt="Shiba Dog">
            <div class="dog-message" id="dogMessage">"Woof! Connect your wallet to start swapping, pup!"</div>
        </div>
    </div>
    <div class="modal" id="tokenModal">
        <div class="modal-content">
            <h3>Select a token</h3>
            <div id="tokenList"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const tokens = [
            { address: "0xeCe898EdCc0AF91430603175F945D8de75291c70", symbol: "DAMN", logo: "images/damn.png" },
            { address: "0xe9Cb2D7ADC24Fc59FE00D6C0A0669BDF16805Fe0", symbol: "FEED", logo: "images/feed.png" },
            { address: "0x8f4b11d923BbAA6206f3Dd3ff84e8e31bafB49b7", symbol: "WOW", logo: "images/wow.png" },
            { address: "0x632d1FF1fB27d88EdeDB90e70bFC094D7932A0ad", symbol: "SHIPA", logo: "images/shipa.png" },
            { address: "0x61CFA29261d8151D39244b8FfCf8DFd2f9DF3839", symbol: "CHIKA", logo: "images/chika.png" },
            { address: "0xD0daa7B6ff1B40d3cc6F0B2Cf7E85cB993D1c834", symbol: "WOOF", logo: "images/woof.png" },
            { address: "0x0b4FD6288b6d32171CC515bfFC9340026F56A358", symbol: "PIKA", logo: "images/pika.png" },
            { address: "0x0cCD687CC6F8461170336D8e8cf46A39313DEab9", symbol: "LUISA", logo: "images/luisa.png" },
            { address: "0xB9Ae1d4e474CC154F48e5C2f0559Eb3A78Ad1F09", symbol: "SHIBS", logo: "images/shibs.png" },
            { address: "0x0C7f96C5f141Df976f8680044082c48C351f8906", symbol: "WILD", logo: "images/wild.png" },
            { address: "0x91fbB2503AC69702061f1AC6885759Fc853e6EaE", symbol: "KNINE", logo: "images/knine.png" },
            { address: "0x9f56cba9c3d4cd9f3d7b899ea0ff8292fe8264a8", symbol: "DUDU", logo: "images/dudu.png" },
            { address: "0x8ed7d143Ef452316Ab1123d28Ab302dC3b80d3ce", symbol: "ETH", logo: "images/eth.png" },
            { address: "0x495eea66B0f8b636D441dC6a98d8F5C3D455C4c0", symbol: "SHIB", logo: "images/shib.png" },
            { address: "0x65218A41Fb92637254B4f8c97448d3dF343A3064", symbol: "LEASH", logo: "images/leash.png" },
            { address: "0xaB082b8ad96c7f47ED70ED971Ce2116469954cFB", symbol: "USDT", logo: "images/usdt.png" },
            { address: "0x60Af8e3BCa91E68B3d36141E0f3403C316004Af5", symbol: "MWRX", logo: "images/mwrx.png" },
            { address: "0x506d8d2d9c715Eb34F514cc3EF48C7aBD19e2bc7", symbol: "TREAT", logo: "images/treat.png" }
        ];
        const boneToken = { address: "0x839FdB6cc98342B428E074C1573ADF6D48CA3bFd", symbol: "BONE", logo: "images/bone.png", isNative: true };
        const routerAddress = "0x96b16aBD53Bfd765F4CD118590C1d0be8B57DE24";
        const factoryAddress = "0xB9fbdFA27B7ba8BB2d4bB4aB399e4c55F0F7F83a";
        const wethAddress = "0x839FdB6cc98342B428E074C1573ADF6D48CA3bFd";
        const routerAbi = [
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    { "internalType": "address", "name": "tokenFrom", "type": "address" },
                    { "internalType": "address", "name": "tokenTo", "type": "address" },
                    { "internalType": "bool", "name": "stable", "type": "bool" },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactTokensForTokensSimple",
                "outputs": [
                    { "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    {
                        "components": [
                            { "internalType": "address", "name": "from", "type": "address" },
                            { "internalType": "address", "name": "to", "type": "address" },
                            { "internalType": "bool", "name": "stable", "type": "bool" }
                        ],
                        "internalType": "struct Router.route[]",
                        "name": "routes",
                        "type": "tuple[]"
                    },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    {
                        "components": [
                            { "internalType": "address", "name": "from", "type": "address" },
                            { "internalType": "address", "name": "to", "type": "address" },
                            { "internalType": "bool", "name": "stable", "type": "bool" }
                        ],
                        "internalType": "struct Router.route[]",
                        "name": "routes",
                        "type": "tuple[]"
                    },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactETHForTokensSupportingFeeOnTransferTokens",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    { "internalType": "uint256", "name": "amountOutMin", "type": "uint256" },
                    {
                        "components": [
                            { "internalType": "address", "name": "from", "type": "address" },
                            { "internalType": "address", "name": "to", "type": "address" },
                            { "internalType": "bool", "name": "stable", "type": "bool" }
                        ],
                        "internalType": "struct Router.route[]",
                        "name": "routes",
                        "type": "tuple[]"
                    },
                    { "internalType": "address", "name": "to", "type": "address" },
                    { "internalType": "uint256", "name": "deadline", "type": "uint256" }
                ],
                "name": "swapExactTokensForETHSupportingFeeOnTransferTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    { "internalType": "uint256", "name": "amountIn", "type": "uint256" },
                    {
                        "components": [
                            { "internalType": "address", "name": "from", "type": "address" },
                            { "internalType": "address", "name": "to", "type": "address" },
                            { "internalType": "bool", "name": "stable", "type": "bool" }
                        ],
                        "internalType": "struct Router.route[]",
                        "name": "routes",
                        "type": "tuple[]"
                    }
                ],
                "name": "getAmountsOut",
                "outputs": [
                    { "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        const factoryAbi = [
            { "inputs": [{ "internalType": "address", "name": "tokenA", "type": "address" }, { "internalType": "address", "name": "tokenB", "type": "address" }, { "internalType": "bool", "name": "stable", "type": "bool" }], "name": "getPair", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }
        ];
        const pairAbi = [
            { "inputs": [], "name": "getReserves", "outputs": [{ "internalType": "uint256", "name": "reserve0", "type": "uint256" }, { "internalType": "uint256", "name": "reserve1", "type": "uint256" }, { "internalType": "uint32", "name": "blockTimestampLast", "type": "uint32" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "token0", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "token1", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "stable", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }
        ];
        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"}
        ];
        const shibarium = {
            chainId: 109,
            chainName: 'Shibarium',
            nativeCurrency: { name: 'BONE', symbol: 'BONE', decimals: 18 },
            rpcUrls: ['https://rpc.shibrpc.com'],
            blockExplorerUrls: ['https://shibariumscan.io']
        };
        let web3, account, router, factory;
        let fromToken = boneToken;
        let toToken = null;
        let fromBalance = '0';
        let isFromBone = true;
        const defaultSlippage = 0.005;
        const maxPriceImpact = 0.5; // 50% price impact threshold

        // Random dog message generator
        const dogMessages = {
            connectStart: [
                "Woof woof! Sniffing out your wallet, hold tight, human!",
                "Arf! Digging into Shibarium, let’s fetch that wallet!",
                "Bow wow! Connecting to your stash, stay pawsitive!",
                "Woof! I smell a wallet, let’s link it up quick!"
            ],
            connectSuccess: [
                "Arf arf! You’re in, pup! Time to chase some BONEs!",
                "Woof! Wallet’s hooked, ready to roll in Shibarium!",
                "Yip yip! Connected, hooman! Let’s swap some treats!",
                "Bow wow! Welcome aboard, let’s sniff out some swaps!"
            ],
            connectFail: [
                "Grrr... Wallet slipped away, try again, hooman!",
                "Woof? No wallet scent detected, give it another go!",
                "Arf arf! Something barked up, retry connecting, pup!",
                "Ruff! Wallet’s hiding, let’s dig it out again!"
            ],
            tokenModal: [
                "Woof! Pick a token, let’s sniff out a juicy deal!",
                "Arf! What treat shall we fetch today, hooman?",
                "Bow wow! Tokens galore, choose your fave, pup!",
                "Yip! Time to pick a bone to swap, let’s go!"
            ],
            selectToken: (symbol) => [
                `Arf arf! ${symbol}, huh? Smells like a tasty choice!`,
                `Woof! ${symbol} caught your eye? Good nose, pup!`,
                `Bow wow! ${symbol} it is! Let’s wag into action!`,
                `Yip yip! ${symbol} sounds pawsome, ready to swap?`
            ],
            switchTokens: [
                "Woof woof! Flipping tokens like a Shib pro, huh?",
                "Arf! Swapping sides, let’s keep the tail wagging!",
                "Bow wow! Token switcheroo, you’re a clever pup!",
                "Ruff ruff! Mixing it up, let’s see what we fetch!"
            ],
            setPercentage: (percent) => [
                `Woof! ${percent}% in? You’re a bold Shib, hooman!`,
                `Arf arf! Going ${percent}%? Let’s dig into that swap!`,
                `Bow wow! ${percent}% of the stash? Pawsitively daring!`,
                `Yip! ${percent}%? You’re chasing big bones today!`
            ],
            calcStart: [
                "Woof! Sniffing out the best price, hang tight!",
                "Arf! Digging up some swap numbers, stay put, pup!",
                "Bow wow! Crunching bones, I’ll fetch the output soon!",
                "Ruff! Calculating your treat, give me a sec, hooman!"
            ],
            calcSuccess: (amount, symbol) => [
                `Arf! Found ya ${amount} ${symbol}! Ready to swap, pup?`,
                `Woof woof! Snagged ${amount} ${symbol}, let’s roll!`,
                `Yip yip! Dug up ${amount} ${symbol}, happy tail wags!`,
                `Bow wow! ${amount} ${symbol} sniffed out, swap time!`
            ],
            calcFail: [
                "Grrr... No path for these bones, try a new pair, pup!",
                "Woof? Swap trail’s cold, pick another token, hooman!",
                "Arf arf! Couldn’t fetch the output, let’s retry!",
                "Ruff! Swap math barked up, give it another go!"
            ],
            swapStart: [
                "Woof woof! Swapping time, let’s fetch those tokens!",
                "Arf! Launching the swap, hold onto your leash, pup!",
                "Bow wow! Trading bones, here we go, Shib style!",
                "Yip! Swapping in Shibarium, let’s make it pawsome!"
            ],
            swapSuccess: [
                "Arf arf! Swap done, you’re a Woofswap champ, hooman!",
                "Woof! Tokens fetched, tail-wagging success, pup!",
                "Bow wow! Swapped like a pro, time to celebrate!",
                "Yip yip! Swap complete, you’re the top dog now!"
            ],
            swapFail: [
                "Grrr... Swap didn’t work, let’s try again, pup!",
                "Woof? Swap got lost, retry it, clever hooman!",
                "Arf! Token chase failed, another go, Shib friend?",
                "Ruff ruff! Swap slipped, let’s dig it up again!"
            ],
            swapNoToken: [
                "Woof? Missing a token, pup! Pick one first!",
                "Arf arf! No treats to swap, choose a pair, hooman!",
                "Bow wow! Where’s the token? Let’s sniff one out!",
                "Yip! Can’t swap air, pick a token, Shib pal!"
            ],
            swapNoAmount: [
                "Arf! No amount? How am I supposed to swap air?!",
                "Woof woof! Gimme a number, pup, or we’re stuck!",
                "Bow wow! Empty swap? Fill it up, hooman!",
                "Ruff! Amount’s missing, let’s fetch some digits!"
            ],
            highPriceImpact: [
                "Woof woof! That swap has a huge price impact, pup! Try a smaller amount!",
                "Arf! Too many bones at once—price impact’s too high, hooman!",
                "Bow wow! Swap’s too big for the pool, let’s scale it down!",
                "Ruff! Price impact’s barking mad—reduce the amount, Shib friend!"
            ],
            insufficientLiquidity: [
                "Grrr... Not enough bones in the pool for this swap, pup!",
                "Woof? Pool’s too shallow—try a smaller swap, hooman!",
                "Arf arf! Liquidity’s low, can’t fetch that many bones!",
                "Ruff! Pool’s running dry—let’s try a smaller trade!"
            ]
        };

        function getRandomMessage(type, param1, param2) {
            const messages = dogMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('toToken').addEventListener('click', () => showTokenModal('to'));
        });

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            const dogMessage = document.getElementById('dogMessage');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask or another wallet.");
                connectButton.disabled = true;
                status.innerText = "Connecting...";
                dogMessage.innerText = getRandomMessage('connectStart');
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                const chainId = await web3.eth.getChainId();
                if (Number(chainId) !== 109) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: "0x6d" }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [shibarium]
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                connectButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                status.innerText = "Connected to Shibarium";
                dogMessage.innerText = getRandomMessage('connectSuccess');
                await updateBalances();
            } catch (error) {
                status.innerText = "Failed: " + error.message;
                dogMessage.innerText = getRandomMessage('connectFail');
                console.error(error);
                connectButton.disabled = false;
            }
        }

        async function updateBalances() {
            if (!web3 || !account) return;
            if (fromToken.isNative) {
                fromBalance = await web3.eth.getBalance(account);
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            } else {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                fromBalance = await tokenContract.methods.balanceOf(account).call();
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            }
            if (toToken) {
                let toBalance;
                if (toToken.isNative) {
                    toBalance = await web3.eth.getBalance(account);
                } else {
                    const toTokenContract = new web3.eth.Contract(erc20Abi, toToken.address);
                    toBalance = await toTokenContract.methods.balanceOf(account).call();
                }
                document.getElementById('toBalance').innerText = `Balance: ${web3.utils.fromWei(toBalance, 'ether')}`;
            }
        }

        function showTokenModal(type) {
            const modal = document.getElementById('tokenModal');
            const tokenList = document.getElementById('tokenList');
            const dogMessage = document.getElementById('dogMessage');
            tokenList.innerHTML = '';
            tokens.forEach(token => {
                const div = document.createElement('div');
                div.className = 'token-item';
                div.innerHTML = `<img src="${token.logo}" alt="${token.symbol}"><span>${token.symbol}</span>`;
                div.onclick = () => selectToken(token, type);
                tokenList.appendChild(div);
            });
            modal.style.display = 'block';
            dogMessage.innerText = getRandomMessage('tokenModal');
            modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        }

        function selectToken(token, type) {
            const dogMessage = document.getElementById('dogMessage');
            if (type === 'to') {
                toToken = token;
                document.getElementById('toToken').innerHTML = `<div><img src="${token.logo}" alt="${token.symbol}"><span>${token.symbol}</span></div><span>▼</span>`;
                if (isFromBone) {
                    fromToken = boneToken;
                } else {
                    fromToken = token;
                    toToken = boneToken;
                    document.getElementById('fromToken').innerHTML = `<div><img src="${fromToken.logo}" alt="${fromToken.symbol}"><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
                }
            }
            document.getElementById('tokenModal').style.display = 'none';
            dogMessage.innerText = getRandomMessage('selectToken', token.symbol);
            updateBalances();
            calculateOutput();
        }

        function switchTokens() {
            const dogMessage = document.getElementById('dogMessage');
            if (!toToken) {
                document.getElementById('networkStatus').innerText = "Please select a token to swap to.";
                dogMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            isFromBone = !isFromBone;
            [fromToken, toToken] = [toToken, fromToken];
            document.getElementById('fromToken').innerHTML = `<div><img src="${fromToken.logo}" alt="${fromToken.symbol}"><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
            document.getElementById('toToken').innerHTML = `<div><img src="${toToken.logo}" alt="${toToken.symbol}"><span>${toToken.symbol}</span></div><span>▼</span>`;
            dogMessage.innerText = getRandomMessage('switchTokens');
            updateBalances();
            calculateOutput();
        }

        function setPercentage(percentage) {
            const dogMessage = document.getElementById('dogMessage');
            if (!fromBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount = web3.utils.fromWei(fromBalance, 'ether') * (percentage / 100);
            if (percentage === 100 && fromToken.isNative) {
                amount = Math.max(0, amount - 0.01);
            }
            document.getElementById('fromAmount').value = amount.toFixed(2);
            dogMessage.innerText = getRandomMessage('setPercentage', percentage);
            calculateOutput();
        }

        async function calculateOutput() {
            const amountIn = document.getElementById('fromAmount').value;
            const swapNote = document.getElementById('swapNote');
            const dogMessage = document.getElementById('dogMessage');
            if (!web3 || !account || !toToken || !amountIn || amountIn <= 0) {
                swapNote.innerHTML = 'Amount automatically calculated by Woofswap';
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                swapNote.innerHTML = 'Invalid amount entered.';
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            swapNote.innerHTML = `Estimated output: <span class="spinner"></span>`;
            dogMessage.innerText = getRandomMessage('calcStart');
            try {
                let bestOutput = web3.utils.toBN('0');
                let bestStable = false;
                for (const stable of [true, false]) {
                    const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                    if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                        const routes = [{ from: fromToken.address, to: toToken.address, stable }];
                        const amounts = await router.methods.getAmountsOut(amountInWei, routes).call();
                        const output = web3.utils.toBN(amounts[amounts.length - 1]);
                        if (output.gt(bestOutput)) {
                            bestOutput = output;
                            bestStable = stable;
                        }
                    }
                }
                if (bestOutput.eq(web3.utils.toBN('0'))) {
                    swapNote.innerHTML = 'No valid trading pair found.';
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }

                // Estimate price impact
                const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, bestStable).call();
                const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
                const reserves = await pairContract.methods.getReserves().call();
                const token0 = await pairContract.methods.token0().call();
                const reserveFrom = token0 === fromToken.address ? reserves.reserve0 : reserves.reserve1;
                const reserveTo = token0 === fromToken.address ? reserves.reserve1 : reserves.reserve0;
                const reserveFromBN = web3.utils.toBN(reserveFrom);
                const reserveToBN = web3.utils.toBN(reserveTo);
                const priceImpact = amountInWei.mul(web3.utils.toBN(100)).div(reserveFromBN.add(amountInWei));
                if (priceImpact.gt(web3.utils.toBN(maxPriceImpact * 100))) {
                    swapNote.innerHTML = `Price impact too high (${priceImpact.toString()}%).`;
                    dogMessage.innerText = getRandomMessage('highPriceImpact');
                    return;
                }

                // Check if pool has enough liquidity
                if (bestOutput.gt(reserveToBN)) {
                    swapNote.innerHTML = `Insufficient liquidity in pool.`;
                    dogMessage.innerText = getRandomMessage('insufficientLiquidity');
                    return;
                }

                const outputEther = parseFloat(web3.utils.fromWei(bestOutput, 'ether'));
                swapNote.innerHTML = `Estimated output: ${outputEther.toFixed(6)} ${toToken.symbol}`;
                dogMessage.innerText = getRandomMessage('calcSuccess', outputEther.toFixed(2), toToken.symbol);
            } catch (error) {
                console.error("Error calculating output:", error);
                swapNote.innerHTML = 'Error calculating output.';
                dogMessage.innerText = getRandomMessage('calcFail');
            }
        }

        async function approveToken(tokenAddress, amount) {
            if (tokenAddress === wethAddress && fromToken.isNative) return;
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, routerAddress).call();
            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(amount))) {
                await tokenContract.methods.approve(routerAddress, web3.utils.toWei('1000000', 'ether')).send({ from: account });
                document.getElementById('networkStatus').innerText = "Token approved";
            }
        }

        async function swapTokens() {
            const dogMessage = document.getElementById('dogMessage');
            const status = document.getElementById('networkStatus');
            if (!web3 || !account || !toToken) {
                status.innerText = "Please connect wallet and select tokens.";
                dogMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            const amountIn = document.getElementById('fromAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }

            // Convert to BigNumber and validate input
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                console.error("Amount conversion error:", error);
                return;
            }

            // Check balance for non-native tokens
            if (!fromToken.isNative) {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                const tokenBalance = await tokenContract.methods.balanceOf(account).call();
                if (web3.utils.toBN(tokenBalance).lt(amountInWei)) {
                    status.innerText = "Insufficient token balance.";
                    dogMessage.innerText = "Woof! Not enough bones to swap, pup!";
                    return;
                }
            }

            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            let bestStable = false;
            let bestOutput = web3.utils.toBN('0');
            let routes;

            try {
                for (const stable of [true, false]) {
                    const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                    if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                        const tempRoutes = [{ from: fromToken.address, to: toToken.address, stable }];
                        const amounts = await router.methods.getAmountsOut(amountInWei, tempRoutes).call();
                        const output = web3.utils.toBN(amounts[amounts.length - 1]);
                        if (output.gt(bestOutput)) {
                            bestOutput = output;
                            bestStable = stable;
                            routes = tempRoutes;
                        }
                    }
                }
                if (bestOutput.eq(web3.utils.toBN('0')) || !routes) {
                    status.innerText = "No valid trading pair found.";
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }

                // Estimate price impact
                const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, bestStable).call();
                const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
                const reserves = await pairContract.methods.getReserves().call();
                const token0 = await pairContract.methods.token0().call();
                const reserveFrom = token0 === fromToken.address ? reserves.reserve0 : reserves.reserve1;
                const reserveTo = token0 === fromToken.address ? reserves.reserve1 : reserves.reserve0;
                const reserveFromBN = web3.utils.toBN(reserveFrom);
                const reserveToBN = web3.utils.toBN(reserveTo);
                const priceImpact = amountInWei.mul(web3.utils.toBN(100)).div(reserveFromBN.add(amountInWei));
                if (priceImpact.gt(web3.utils.toBN(maxPriceImpact * 100))) {
                    status.innerText = `Price impact too high (${priceImpact.toString()}%).`;
                    dogMessage.innerText = getRandomMessage('highPriceImpact');
                    return;
                }

                // Check if pool has enough liquidity
                if (bestOutput.gt(reserveToBN)) {
                    status.innerText = `Insufficient liquidity in pool.`;
                    dogMessage.innerText = getRandomMessage('insufficientLiquidity');
                    return;
                }

                // Apply slippage with BigNumber
                const slippageFactor = web3.utils.toBN(1000 - defaultSlippage * 1000); // 995 for 0.5% slippage
                const amountOutMin = bestOutput.mul(slippageFactor).div(web3.utils.toBN(1000));

                // Debug logging
                console.log("amountInWei:", amountInWei.toString());
                console.log("bestOutput:", bestOutput.toString());
                console.log("amountOutMin:", amountOutMin.toString());
                console.log("reserveFrom:", reserveFromBN.toString());
                console.log("reserveTo:", reserveToBN.toString());
                console.log("priceImpact:", priceImpact.toString() + "%");

                status.innerText = "Processing swap...";
                dogMessage.innerText = getRandomMessage('swapStart');

                if (!fromToken.isNative) {
                    await approveToken(fromToken.address, amountInWei);
                }

                if (fromToken.isNative) {
                    await router.methods.swapExactETHForTokensSupportingFeeOnTransferTokens(
                        amountOutMin.toString(),
                        routes,
                        account,
                        deadline
                    ).send({ from: account, value: amountInWei });
                } else {
                    await router.methods.swapExactTokensForETHSupportingFeeOnTransferTokens(
                        amountInWei.toString(),
                        amountOutMin.toString(),
                        routes,
                        account,
                        deadline
                    ).send({ from: account });
                }

                status.innerText = "Swap successful!";
                dogMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('fromAmount').value = '';
                await updateBalances();
            } catch (error) {
                console.error("Swap failed:", error);
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("INSUFFICIENT_OUTPUT_AMOUNT") || error.message.includes("EXCESSIVE_INPUT_AMOUNT")) {
                    errorMessage = "Swap failed: Price impact or slippage too high. Try a smaller amount or increase slippage.";
                    dogMessage.innerText = "Woof! Swap failed—too much price impact or slippage. Try less bones or more slippage, pup!";
                } else if (error.message.includes("INSUFFICIENT_LIQUIDITY")) {
                    errorMessage = "Swap failed: Insufficient liquidity in the pool.";
                    dogMessage.innerText = getRandomMessage('insufficientLiquidity');
                } else {
                    dogMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
            }
        }
    </script>
</body>
</html>
